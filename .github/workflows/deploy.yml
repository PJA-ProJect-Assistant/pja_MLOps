# .github/workflows/deploy.yml
name: PJA Project CI/CD Pipeline

on:
  push:
    branches: [ main, develop, seong_work ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, seong_work ]

env:
  REGISTRY: docker.io
  IMAGE_NAME: pja-project
  DOCKER_USERNAME: listgreen

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Check if requirements.txt exists
      run: |
        # FastAPI ë””ë ‰í† ë¦¬ì—ì„œ requirements.txt í™•ì¸
        if [ ! -f FastAPI/requirements.txt ] && [ ! -f requirements.txt ]; then
          echo "âš ï¸ requirements.txt not found, creating basic one in FastAPI directory..."
          mkdir -p FastAPI
          cat > FastAPI/requirements.txt << EOF
        fastapi>=0.104.1
        uvicorn[standard]>=0.24.0
        pydantic>=2.5.0
        openai>=1.3.0
        python-multipart>=0.0.6
        requests>=2.31.0
        python-dotenv>=1.0.0
        EOF
        fi
        
        # requirements.txt ìœ„ì¹˜ í™•ì¸ ë° ì¶œë ¥
        if [ -f FastAPI/requirements.txt ]; then
          echo "ğŸ“‹ FastAPI/requirements.txt content:"
          cat FastAPI/requirements.txt
          REQUIREMENTS_FILE="FastAPI/requirements.txt"
        elif [ -f requirements.txt ]; then
          echo "ğŸ“‹ requirements.txt content:"
          cat requirements.txt
          REQUIREMENTS_FILE="requirements.txt"
        fi
        echo "REQUIREMENTS_FILE=$REQUIREMENTS_FILE" >> $GITHUB_ENV
    
    - name: Install dependencies
      run: |
        pip install uv
        uv pip install --system -r ${{ env.REQUIREMENTS_FILE }}
    
    - name: Check FastAPI files
      run: |
        echo "ğŸ“ Project structure:"
        find . -name "*.py" -type f | head -20
        
        if [ -f FastAPI/main.py ]; then
          echo "âœ… FastAPI/main.py found"
          echo "MAIN_PY_PATH=FastAPI/main.py" >> $GITHUB_ENV
        elif [ -f main.py ]; then
          echo "âœ… main.py found"
          echo "MAIN_PY_PATH=main.py" >> $GITHUB_ENV
        else
          echo "âŒ main.py not found in both root and FastAPI directory"
          echo "MAIN_PY_PATH=" >> $GITHUB_ENV
        fi
    
    - name: Run basic syntax check
      run: |
        if [ -n "${{ env.MAIN_PY_PATH }}" ]; then
          python -m py_compile ${{ env.MAIN_PY_PATH }}
          echo "âœ… ${{ env.MAIN_PY_PATH }} syntax check passed"
        else
          echo "âš ï¸ Skipping syntax check - main.py not found"
        fi
    
    - name: Test FastAPI application (optional)
      run: |
        if [ -f FastAPI/main.py ]; then
          cd FastAPI
          echo "ğŸ§ª Testing FastAPI application startup..."
          timeout 10s python -c "
          import sys
          sys.path.append('.')
          try:
              from main import app
              print('âœ… FastAPI app imported successfully')
          except Exception as e:
              print(f'âš ï¸ FastAPI app import failed: {e}')
              sys.exit(0)
          " || echo "âš ï¸ FastAPI test timed out or failed (this is okay for now)"
        fi

  version:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      contents: write
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      version_type: ${{ steps.version.outputs.version_type }}
      should_deploy: ${{ steps.version.outputs.should_deploy }}
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Get current version and determine next version
      id: version
      run: |
        # í˜„ì¬ ìµœì‹  íƒœê·¸ ê°€ì ¸ì˜¤ê¸° (ì—†ìœ¼ë©´ v0.2.1ë¡œ ì‹œì‘)
        CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.2.1")
        echo "Current tag: $CURRENT_TAG"
        
        # v ì œê±°í•˜ê³  ë²„ì „ë§Œ ì¶”ì¶œ
        CURRENT_VERSION=${CURRENT_TAG#v}
        echo "Current version: $CURRENT_VERSION"
        
        # ì»¤ë°‹ ë©”ì‹œì§€ ë¶„ì„
        COMMIT_MSG=$(git log -1 --pretty=%B)
        echo "Commit message: $COMMIT_MSG"
        
        # ë²„ì „ ì¦ê°€ ë¡œì§
        IFS='.' read -r -a version_parts <<< "$CURRENT_VERSION"
        major=${version_parts[0]:-0}
        minor=${version_parts[1]:-2}
        patch=${version_parts[2]:-1}
        
        SHOULD_DEPLOY="true"
        
        if [[ $COMMIT_MSG == *"BREAKING CHANGE"* ]] || [[ $COMMIT_MSG == *"major:"* ]] || [[ $COMMIT_MSG == *"ë°°í¬ 1.0"* ]]; then
          if [ $major -eq 0 ]; then
            NEW_VERSION="1.0.0"
          else
            NEW_VERSION="$((major + 1)).0.0"
          fi
          VERSION_TYPE="major"
        elif [[ $COMMIT_MSG == *"feat:"* ]] || [[ $COMMIT_MSG == *"ê¸°ëŠ¥"* ]] || [[ $COMMIT_MSG == *"feature"* ]]; then
          NEW_VERSION="$major.$((minor + 1)).0"
          VERSION_TYPE="minor"
        elif [[ $COMMIT_MSG == *"fix:"* ]] || [[ $COMMIT_MSG == *"ì˜¤ë¥˜"* ]] || [[ $COMMIT_MSG == *"bugfix"* ]]; then
          NEW_VERSION="$major.$minor.$((patch + 1))"
          VERSION_TYPE="patch"
        else
          NEW_VERSION="$major.$minor.$((patch + 1))"
          VERSION_TYPE="patch"
        fi
        
        echo "New version: $NEW_VERSION"
        echo "Version type: $VERSION_TYPE"
        
        # íƒœê·¸ê°€ ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
        if git rev-parse "v$NEW_VERSION" >/dev/null 2>&1; then
          echo "âš ï¸ Tag v$NEW_VERSION already exists, skipping deployment"
          SHOULD_DEPLOY="false"
        else
          # Git ì„¤ì •
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # ìƒˆ íƒœê·¸ ìƒì„± ë° í‘¸ì‹œ
          git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION - $VERSION_TYPE update"
          git push origin "v$NEW_VERSION"
          echo "âœ… Created and pushed tag v$NEW_VERSION"
        fi
        
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT
        echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT

  build-and-push:
    needs: [test, version]
    runs-on: ubuntu-latest
    if: always() && (needs.test.result == 'success') && (needs.version.outputs.should_deploy == 'true' || github.event_name == 'pull_request')
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Docker Hub
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}
        tags: |
          type=raw,value=${{ needs.version.outputs.new_version }},enable=${{ needs.version.outputs.new_version != '' }}
          type=ref,event=branch
          type=ref,event=pr
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./FastAPI
        platforms: linux/amd64
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          VERSION=${{ needs.version.outputs.new_version || 'dev' }}

  # SSH ì—°ê²° í…ŒìŠ¤íŠ¸ ë‹¨ê³„ ì¶”ê°€
  test-ssh:
    needs: [build-and-push, version]
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/seong_work') && needs.version.outputs.should_deploy == 'true'
    
    steps:
    - name: Test SSH Connection
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.AWS_HOST }}
        username: ${{ secrets.AWS_USERNAME }}
        key: ${{ secrets.AWS_PRIVATE_KEY }}
        port: 22
        timeout: 30s
        debug: true
        script: |
          echo "âœ… SSH connection successful!"
          echo "Current user: $(whoami)"
          echo "Current directory: $(pwd)"
          echo "Docker version: $(docker --version)"
          echo "Available disk space:"
          df -h

  deploy:
    needs: [test-ssh, version]
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/seong_work') && needs.version.outputs.should_deploy == 'true'
    
    steps:
    - name: Deploy to AWS EC2
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.AWS_HOST }}
        username: ${{ secrets.AWS_USERNAME }}
        key: ${{ secrets.AWS_PRIVATE_KEY }}
        port: 22
        timeout: 120s
        command_timeout: 20m
        debug: true
        script: |
          echo "ğŸš€ Deploying PJA_Project version: ${{ needs.version.outputs.new_version }}"
          
          # í™˜ê²½ë³€ìˆ˜ ì„¤ì •
          export DOCKER_USERNAME="listgreen"
          export IMAGE_TAG="${{ needs.version.outputs.new_version }}"
          export OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}"
          
          # Docker ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸
          echo "ğŸ” Checking Docker service status..."
          sudo systemctl status docker --no-pager || echo "Docker service check failed"
          
          # Docker ë¡œê·¸ì¸
          echo "ğŸ” Logging into Docker Hub..."
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin || {
            echo "âš ï¸ Docker login failed, continuing..."
          }
          
          # ê¸°ì¡´ ì»¨í…Œì´ë„ˆ ì •ë¦¬
          echo "ğŸ§¹ Cleaning up existing containers..."
          docker stop pja-fastapi 2>/dev/null || echo "No container to stop"
          docker rm pja-fastapi 2>/dev/null || echo "No container to remove"
          
          # ê¸°ì¡´ ì´ë¯¸ì§€ ì •ë¦¬ (ë””ìŠ¤í¬ ê³µê°„ í™•ë³´)
          echo "ğŸ—‘ï¸ Cleaning up unused images..."
          docker image prune -f || echo "Image cleanup failed"
          
          # ìƒˆ ì´ë¯¸ì§€ í’€
          echo "ğŸ“¥ Pulling new image: $DOCKER_USERNAME/pja-project:$IMAGE_TAG"
          if ! docker pull $DOCKER_USERNAME/pja-project:$IMAGE_TAG; then
            echo "âŒ Failed to pull versioned image, trying latest tag..."
            if ! docker pull $DOCKER_USERNAME/pja-project:latest; then
              echo "âŒ Failed to pull latest image as well"
              exit 1
            fi
            IMAGE_TAG="latest"
          fi
          
          # ì´ë¯¸ì§€ í™•ì¸
          echo "ğŸ“‹ Available images:"
          docker images | grep pja-project || echo "No pja-project images found"
          
          # ìƒˆ ì»¨í…Œì´ë„ˆ ì‹¤í–‰
          echo "ğŸš€ Starting new container..."
          docker run -d \
            --name pja-fastapi \
            -p 8000:8000 \
            -e OPENAI_API_KEY="$OPENAI_API_KEY" \
            --restart unless-stopped \
            --health-cmd="curl -f http://localhost:8000/docs || exit 1" \
            --health-interval=30s \
            --health-timeout=10s \
            --health-retries=3 \
            $DOCKER_USERNAME/pja-project:$IMAGE_TAG
          
          # ì»¨í…Œì´ë„ˆ ì‹œì‘ ëŒ€ê¸°
          echo "â³ Waiting for container to start..."
          sleep 30
          
          # ì»¨í…Œì´ë„ˆ ìƒíƒœ í™•ì¸
          echo "ğŸ” Checking container status..."
          docker ps -a | grep pja-fastapi || echo "Container not found"
          
          if ! docker ps | grep pja-fastapi > /dev/null; then
            echo "âŒ Container failed to start"
            echo "ğŸ“‹ Container logs:"
            docker logs pja-fastapi --tail 100 2>/dev/null || echo "Failed to get logs"
            echo "ğŸ” Container inspect:"
            docker inspect pja-fastapi 2>/dev/null || echo "Failed to inspect container"
            exit 1
          fi
          
          # ì»¨í…Œì´ë„ˆ ë¡œê·¸ í™•ì¸
          echo "ğŸ“‹ Container startup logs:"
          docker logs pja-fastapi --tail 20
          
          # Health check with better error handling
          echo "ğŸ¥ Performing health check..."
          HEALTH_CHECK_PASSED=false
          
          for i in {1..10}; do
            echo "â³ Health check attempt $i/10..."
            
            # ì»¨í…Œì´ë„ˆê°€ ì—¬ì „íˆ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸
            if ! docker ps | grep pja-fastapi > /dev/null; then
              echo "âŒ Container stopped during health check"
              docker logs pja-fastapi --tail 30
              exit 1
            fi
            
            # HTTP ìš”ì²­ í…ŒìŠ¤íŠ¸
            if curl -f -s --max-time 10 http://localhost:8000/docs > /dev/null 2>&1; then
              echo "âœ… Health check passed (attempt $i/10)"
              HEALTH_CHECK_PASSED=true
              break
            elif curl -f -s --max-time 10 http://localhost:8000/ > /dev/null 2>&1; then
              echo "âœ… Basic health check passed (attempt $i/10)"
              HEALTH_CHECK_PASSED=true
              break
            else
              echo "âš ï¸ Health check failed, retrying in 15s..."
              sleep 15
            fi
          done
          
          if [ "$HEALTH_CHECK_PASSED" = false ]; then
            echo "âŒ Health check failed after 10 attempts"
            echo "ğŸ“‹ Final container logs:"
            docker logs pja-fastapi --tail 50
            echo "ğŸ” Container status:"
            docker ps -a | grep pja-fastapi
            echo "ğŸŒ Network test:"
            netstat -tlnp | grep :8000 || echo "Port 8000 not listening"
            exit 1
          fi
          
          # ìµœì¢… ìƒíƒœ í™•ì¸
          echo "ğŸ“¦ Current running containers:"
          docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
          
          echo "ğŸ‰ Deployment completed successfully!"
          
          # ì™¸ë¶€ IP í™•ì¸ ë° URL ì¶œë ¥
          EXTERNAL_IP=$(curl -s --max-time 10 http://checkip.amazonaws.com || echo "unknown")
          echo "ğŸŒ Application URL: http://$EXTERNAL_IP:8000/docs"
          echo "ğŸ“Š Health status: http://$EXTERNAL_IP:8000/"
